local gamelift = require "aws-sdk.gamelift"
local flow = require "ludobits.m.flow"

local FLEET_ID = "foobar"



local function create_unqiue_player_id()
	-- need to put this in aws-sdk.utils or possibly in a separate gamelift repo?
	return "foo"
end

local function show_popup(title, body, action1, action2)
	msg.post(".", "release_input_focus")
	msg.post("/popup", "show", { title = title, body = body, action1 = action1, action2 = action2 })
end

local function hide_popup()
	msg.post(".", "acquire_input_focus")
	msg.post("/popup", "hide")
end

local function sleep(seconds)
	local co = coroutine.running()
	timer.seconds(seconds, function()
		coroutine.resume(co)
	end)
	coroutine.yield()
end

local function list_aliases()
	local input = gamelift.ListAliasesInput()
	return gamelift.ListAliasesSync(input)
end

local function search_game_sessions(alias_id)
	local input = gamelift.SearchGameSessionsInput(nil, nil, nil, 10, nil, alias_id)
	return gamelift.SearchGameSessionsSync(input)
end


local function describe_game_session(game_session_id)
	local input = gamelift.DescribeGameSessionsInput(nil, game_session_id, nil, nil, nil, nil)
	return gamelift.DescribeGameSessionsSync(input)
end


-- create game session on a specific fleet
-- From integration docs:
-- This synchronous operation succeeds or fails depending on whether or not the fleet has
-- resources available to host a new game session. Your game should handle failures as best
-- suits your game and players. For example, you might repeat the request until resources
-- are freed or scaled up, or you might switch to a different fleet. Once Amazon GameLift
-- has created the new game session and returned a GameSession object, you can start joining
-- players to it.
local function create_game_session(creator_id, alias_id, session_name, max_users)
	local input = gamelift.CreateGameSessionInput(
		max_users,
		session_name,
		nil, -- GamePropertyList
		nil, -- idempotency_token
		nil, -- fleet_id,
		creator_id,
		nil, -- game_session_id
		alias_id)
	return gamelift.CreateGameSessionSync(input)
end


local function create_game_session_and_wait_until_active(creator_id, alias_id, session_name, max_users)
	local response, error_message = create_game_session(creator_id, alias_id, session_name, max_users)
	if error_message or response.GameSession.Status == "ERROR" then
		return nil, error_message or "STATUS: ERROR"
	end
	local game_session = response.GameSession
	while true do
		local response, error_message = describe_game_session(game_session.GameSessionId)
		if error_message or #response.GameSessions == 0 or response.GameSessions[1].Status == "ERROR" then
			return nil, error_message or "STATUS: ERROR"
		end
		if response.GameSessions[1].Status == "ACTIVE" then
			return game_session
		end
		sleep(5)
	end
end


local function join_game_session(player_id, game_session_id)
	local input = gamelift.CreatePlayerSessionInput(player_id, game_session_id, nil)
	return gamelift.CreatePlayerSessionSync(input)
end



local function populate_game_session_list(self, GameSessionList)
	while #self.games > 0 do
		local node = table.remove(self.games).nodes[hash("game_session_proto/bg")]
		gui.delete_node(node)
	end
	
	local pos = gui.get_position(self.game_session_proto)
	local size = gui.get_size(self.game_session_proto)
	for i,GameSession in ipairs(GameSessionList) do
		local status = GameSession.status
		local max = GameSession.MaximumPlayerSessionCount
		local name = GameSession.Name
		local current = GameSession.CurrentPlayerSessionCount
		
		local nodes = gui.clone_tree(self.game_session_proto)
		gui.set_enabled(nodes[hash("game_session_proto/bg")], true)
		gui.set_enabled(nodes[hash("game_session_proto/join/button")], current < max)
		gui.set_position(nodes[hash("game_session_proto/bg")], pos)
		gui.set_text(nodes[hash("game_session_proto/name")], name)
		gui.set_text(nodes[hash("game_session_proto/players")], ("%d / %d"):format(current, max))
		table.insert(self.games, { nodes = nodes, session = GameSession })
		pos.y = pos.y - (size.y + 10)
	end
end


function init(self)
	--msg.post("@render:", "clear_color", { color = vmath.vector4() })
	msg.post(".", "acquire_input_focus")
	
	self.player = { id = create_unqiue_player_id() }
	
	self.games = {}
	self.game_session_proto = gui.get_node("game_session_proto/bg")
	self.start_game = gui.get_node("start_game/button")
	self.create_game = gui.get_node("create_game/button")
	gui.set_enabled(self.game_session_proto, false)
	
	coroutine.wrap(function()
		local response, error_message = list_aliases()
		if error_message then
			return
		end
		self.alias_id = response.Aliases[1].AliasId
		while true do
			local response, error_message = search_game_sessions(self.alias_id)
			if error_message then
				return
			end
			populate_game_session_list(self, response.GameSessions)
			sleep(5)
		end
	end)()
end

function final(self)
	flow.stop()
end

function on_message(self, message_id, message, sender)
	if message_id == hash("close_popup") then
		hide_popup()
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released then
		for _,game in pairs(self.games) do
			if gui.pick_node(game.nodes[hash("game_session_proto/join/button")], action.x, action.y) then
				coroutine.wrap(function()
					show_popup("JOINING", "Joining game. Please wait.", { text = "Cancel", message_id = "cancel_join_game_session" })
					local response, error_message = join_game_session(self.player.id, game.session.GameSessionId)
					if error_message then
						show_popup("ERROR", "Unable to join game session", { text = "CLOSE", message_id = "close_popup" })
					else
						local server_ip = response.PlayerSession.IpAddress
						local server_port = response.PlayerSession.Port
						msg.post("controller:/controller", "startgame", { ip = server_ip, port = server_port })
					end
				end)()

				return
			end
		end

		if gui.pick_node(self.create_game, action.x, action.y) then
			flow(function()
				show_popup("CREATING GAME", "Creating a new game session. Please wait.", { text = "Cancel", message_id = "cancel_create_game_session" })
				local session, error_message = create_game_session_and_wait_until_active(self.player.id, self.alias_id, "My session", 10)
				if error_message then
					show_popup("ERROR", "Unable to create game session", { text = "CLOSE", message_id = "close_popup" })
				else
					show_popup("SUCCESS", "Game session created", { text = "CLOSE", message_id = "close_popup" })
				end
			end)
		elseif gui.pick_node(self.start_game, action.x, action.y) then
			msg.post("controller:/controller", "startgame", { ip = "127.0.0.1", port = 5000 })
		end
	end
end
